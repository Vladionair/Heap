gAAAAABfUlxYshLWO-XdxhtDKz6TTyO7_VPUAQ2_R4dTzecQ-Ipl2y7qtUJUd1urLm4wzFWBBubX0Oy5o9CqiUjpEaxQOvKeWUveIT1XVfRYw8KrEwF-l2ZRuT0_dS8RPzmnWVsJDFNtOLT_sUG9AwUfc4OrDgGGRkHMRaadkT0kPHhDDheffdCa1fdgvC6zzBBS4NVtUyHUzCq0TVGoIYxacCKBhjCTEx9kOjbHmMS84tWflaI4j0dDGGVz69d4kSO_Ep9u5ttZwOYHDmnYitGhU-0mknOOTrZC883ITMgL09dkcIqQ6VOxB9e-Yy3OMhpwHqulF05YkYX-0hOFWjrRVxKp_Mbs4CJP_KMKO4wMw8xnT8QqsEb1T3gXAIqBaZhsWxU38FGrAtBG8fdioxPV6MEboJCOIfPocltW27mIZQG7En4E4EFk0nxhdcI2jmHdJw9drj4UOqFAE7irv60bnk5m_vNVZdztF_PZJyjzM40mYAEBHwhzVTjUW8k-3dwR9SzHbD6rO38UVtKuTSa9_qqY-I4mDpL2ovYMn2-aWBmBzOJyTmzGWURu2wDMaKUgQ_JE-F3-jCyEcOtOxjMvG1vS9p-oSbFsLBb1EU6Z2_Kh1ViLbGEWrJnOMX1A5qUiU9Sb3Quc5giCq-SG67lDeJMj46HVG_dbVk3t-8Pk5RWtj6wZ-kKWs3MBPjdNWdQHM_FJ_kknshExClNrbk3w2pxtOYSZzIhyoXveYODOW3Cb-lTZhW1wkFcCJQ6qqDee7UiF9Cnh2KfsM0bs1XbJKi_qUksMTJ8IOW2EqFIHA2TUpe5SGMutc0MGgPBidfaUBJ6za0rhIYIJC6wAdASgceO4CKLfEzmYjz_tEPNNOCt35ztlixeAcCp5hCMAl5tJjClbQ7bqTFPY-wkC4aHSHSxQ2immVxlUPin5D7k1sjEefBQlxpeGOTXGNWOgj5Gv9Ry4gzxRP1Z2QRu7eiKuZanmqlvwEfkZTzLgbU9x57NF3f3AigKEgwhwYTwGCpw2jt5inRxql7lsLcFKaSiaWDYO6Xu7mSdwECq1_Of_BgdPpm7-iqq2ymV1va7IxRxLfZAP09hV8T8e0eggLxJ1SQVdM_R5jYZRk2izwwk_QF1NN7wip3Tt0HQlGGpRK8UKO6IevpRa2yW9w2bNl_PauRDscPGiMYwoFiiIKo4hVePN8z3QPhRWUMrLZNWEmPRu-9DRcexM84CyNSEEfhBWxGitKmaq0WlHtPtk8b0-kSvbnPOoTA6Rx4_rEALNU9RYQKHh25KWHG3y6V0wzMB-TNARx31xdnqp9iOddzCGSoGnFO8Dd1OBdkTckUvWCb52B7fLJc-669bOs1t5y7BmgP8xnxlc1Ht6rZKeJcD5PBfewnG-68r_XDFjDvosRPCFrKoFFzt6x2Uj9vMt8Co__aJWpdQCVNdn1LZHjSogein6bhYim84wZq9p-UMqn-_HclDKPik9z-JH0FHiWckfTinHss9x_cZurvzDCcmLcv4NGyVZT2sRAMAfEsM7dkFBCkDgJWeR6397h7M_-XCGakSkWUd_DYnWjt-PcD0cGwTH049vEE_kWox41AT3-jZi3_Lylr5m1WiCMz3W1lWYrq62sKRjdGPKifNtBkqCVS7Ur5rfaRx8D6rdtS2xUJWyrBdEv0cQsvCsYPmmLFBbMmxsRQKSX9FGbT0RAmvOaGh--nPh9pnsw6eRJI__h_82_la4yKjxT3fcDwGmsszPxSzKq3s9zGoTrQX4jx5G3slge3XxYM7EUjbwUS3cGLe6iddFFQwQdFs3DvZFOaMycPa2btEY7E54ml34TyG5DHIZqOvnT6r988y_E3dac8lMnyZW77fORUIdJI8QvPFVwMTB_D3K_4PLu_NDsgmih3FWI53H8tAXlwVY7eCaPgkz5-c7pQOx8clEuCYl39ShgOIu4q25rfdmGR6uzu_IwWaKZA5qHaAMs2ojtn6ow5gcgmJKmWvL7Aaw_Zwbm5wPxgRWZF4tujKhIZhPKGX5Eo1Xqs18lN2e1EywM5cAMjupvTyTLaCKhZrHod1RPdDVdBvNKrsfeojGXmc-rBtsiQ4d0lfF3h1QjWYuX6Rr6CwNRitVU7bJ_TWI8iw2axAMT4vRUvd8JLxn9oqIJzZTwvLOSfe7WUTt3nQBiKQ9RnTMUwmU66UxSfXlrImOHcQtndjj39Zgg_hU190f0ofySFbgqXKPN2N-0J7ALU69lchMvewaaFkV_P4J9de2FCl9Muk-DSPgJG8ckXHytjqOr99P9Cw29abDrEkuCh6xNDi6nZbWpFGaolGH2crnkv1ug8Fpu3F0ALf15gEjzdz63Wz2p5MPTLTfW81-LNdj1WYEKLXdaBuIHAXRk60s-q9FXokKdkr9WryL0FX9ha5rMAOUUqBi8rr3-d1Z5clOYWn6IDhesHHzFw0n3w6XfHWQlfJweA4t3EQhYyfoaHLQK61V84P1t7kE9nW8Ss_SmC_ySyjKaoW4LEHu_bT6z8_NzuWaGOtWEx_-7nzxhzW3BKo0X59Ctb-r8qdpfONl7iz0oB351QcKPccc0M-3sNhYVc7yvq3-v-QicaIFX0ykM3TT4QJwZjo3iDn3648ff57bs_cOUDJJwT0dnRBllg6HaCfDRZK85iW-6WWuhkKaEhLzLWITF5ORKvASHrVRmzCfBzSScM4Y1X28oktXKI2cONOjHeqrVR7H5FBsR0JpH7skeDqLpaoqHiCPxCmuxrlwsrG2P-L044e6RnJRyeTZXYC4_W2VO2RqNO5EcfW6yOIv_SlNm9Latj8c_aQyjjVLfsbkSjug9wlXRpaixp2tJX-8rhyUfTK32knWZVnlF-BsjQoprdyqaaQ5Od1v7SZACOIINgyPtumPnY96_nGUUv7bZDByqKpoOFyeVvWc3lVoM23MznmqRZpeOlNscGi8JuEbpdCIro5sS0512PM5YU5Ke1cbEtxa_lCIhejlXSMAtZW4iaqL4LpKRReV_4iMEyeZ5WevfueLMfOLWH6PlGifoccQBaIVmBZ1PoaILeZHKZjQDpjWnlq_pj6QQ8Zz3zDeHlaA5WIwwkgqUZS3iJE_jAZ2DI5pyf0Au6NWQnZr5-lmSTpVZGR_UToeIfS2HeuZ0SmJYLqIUcLWO2sKbuPoOpYDg-4ESHeMgXg6ihdsf-zM2yzrUaxztBlie_sELWDOnQAnxqR2x16nTLf4TyvIuXnJJBwhnRcTY9ljERxv8yv3HjkIk3iqeY6DpKuzGL2_43ykSOv-wgBnI-yZ8u_OU158xTaeEZ2xHh0dGDgTgNybUvd9nbVrYse6olKOLv5i5ONB43IQzyshJ_XfnfygJmGzpp7WVuGC847YwKozTyxGprXvU6Wn3SctAhq_8Vtb55kX966EEkHZwbRozUl7j0yU1A==

class Heap:

    def __init__(self):

        self.HeapArray = []
		
    def MakeHeap(self, a, depth):

        if a == []:
            return False
        else:
            self.HeapArray = [None] * sum([2 ** i for i in range(depth + 1)])
            for item in a:
                self.Add(item)
            return True

    def GetMax(self):

        if self.HeapArray == []:
            return -1
        else:
            max_elem = self.HeapArray[0]
            index_min = self.HeapArray.index(min(filter(None, self.HeapArray)))
            self.HeapArray[0] = self.HeapArray[index_min]
            self.HeapArray[index_min] = None
            parent = 0
            while 2 * parent + 2 < len(self.HeapArray) and self.HeapArray[2 * parent + 2]:
                if self.HeapArray[parent] < max(self.HeapArray[2 * parent + 1], self.HeapArray[2 * parent + 2]):
                    child = self.HeapArray.index(max(self.HeapArray[2 * parent + 1], self.HeapArray[2 * parent + 2]))
                    self.HeapArray[parent], self.HeapArray[child] = self.HeapArray[child], self.HeapArray[parent]
                    parent = child
                else:
                    break
        return max_elem

    def Add(self, key):

        if None in self.HeapArray:
            child = self.HeapArray.index(None)
            self.HeapArray[child] = key
            while child > 0:
                parent = int((child - 1) / 2)
                if self.HeapArray[child] > self.HeapArray[parent]:
                    self.HeapArray[child], self.HeapArray[parent] = self.HeapArray[parent], self.HeapArray[child]
                    child = parent
                else:
                    break
            return True
        else:
	        return False
	        
import unittest

class Test_Heap(unittest.TestCase):
    
    def setUp(self):

        test.__init__()

    def test_MakeHeap(self):

        test.MakeHeap(a, 3)
        b = [7, 4, 6, 1, 3, 2, 5, None, None, None, None, None, None, None, None]
        self.assertEqual(test.HeapArray, b)
    
    def test_GetMax(self):

        self.assertEqual(test.GetMax(), -1)
        test.MakeHeap(a, 3)
        self.assertEqual(test.GetMax(), 7)
        
    def test_Add(self):

        test.MakeHeap(a, 2)
        self.assertEqual(test.Add(8), False)
        test.GetMax()
        test.Add(7)
        self.assertEqual(test.HeapArray[0], 7)

if __name__ == '__main__':

    a = [1, 2, 3, 4, 5, 6, 7]
    test = Heap()
    unittest.main(verbosity=2)
